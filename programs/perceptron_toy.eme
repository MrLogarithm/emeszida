ğ’¾
# First, jump to ğ’• to load parameters into memory:
ğ’•												ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
---
##############
# def matmul()
ğ’•												jz	ğ’‹¤			ğ’•ğ’•ğ’•ğ’•ğ’•ğ’•
# Counter for rows of A/output, starts at ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’—ğ’„° = dim 1 of A
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’—ğ’„°											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
# Counter for cols of B/output, starts at ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’™ğ’„° = dim 2 of B
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’™ğ’„°											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’˜ğ’˜ğ’˜ğ’˜
# Compute dot product between current row/column:
#   Counter for position in vector, starts at final entry
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’˜ğ’„°											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°		ğ’‘±
#   Accumulator starts at zero
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’˜ğ’„°		ğ’‘±
#   Construct address of current elem in A:
#     Start position is in ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°
#     Row is ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„° >> 2 
ğ’•ğ’‘±												ğ’…†	ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°		ğ’˜
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°		ğ’‘±
#     Col is ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°  >> 3
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°		ğ’‘±
#     Address is start position plus row plus col
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°									ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°								ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°		ğ’‘±
#   Construct address of current elem in B
#     Start position is in ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°
#     Row is ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°  >> 2 
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’œğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’œğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’œğ’„°		ğ’‘±
#     Col is ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’–ğ’„° >> 3
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’–ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’ğ’„°		ğ’‘±
#     Address is start position plus row plus col
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’œğ’„°									ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’Œ‹ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’Œ‹ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’ğ’„°								ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’Œ‹ğ’„°		ğ’‘±
#   Multiply matrix elements
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°ğ’„°  ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’Œ‹ğ’„°ğ’„°							ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’Œ‹ğ’•ğ’„°	ğ’‘±
#   Add to accumulator
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’Œ‹ğ’•ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’˜ğ’„°								ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’˜ğ’„°		ğ’‘±
#   If vector index == 0, break
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°											jz	ğ’˜ğ’˜			ğ’‘±
#   Else decrement vector index
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’—ğ’„°		ğ’‘±
#   And loop to add next term to accumulator
ğ’˜												ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# End dot product loop
ğ’•												jz	ğ’‹¤			ğ’˜ğ’˜
# Write accumulated value to output matrix:
#   Construct address of current elem:
#     Start position is ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’™ğ’„°
#     Row is ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„° >> 2 
ğ’•ğ’‘±												ğ’…†	ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°		ğ’‘±
#     Col is ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’–ğ’„°  >> 3
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’–ğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°  ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’‘±ğ’„°									ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°		ğ’‘±
#     Address is start position plus row plus col
ğ’—ğ’‹™ğ’™ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’™ğ’„°									ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°		ğ’‘±
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’šğ’„°								ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°		ğ’‘±
#   Write accumulated value to computed destination
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’˜ğ’„°											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’›ğ’„°ğ’„°	ğ’‘±
#
# If row counter == 0, break
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„°											jz	ğ’˜ğ’˜ğ’˜			ğ’‘±
# Decrement row counter
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
# Loop back to compute next row of output
ğ’˜ğ’˜ğ’˜ğ’˜											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
#
# NOP placeholder to break out of loop
ğ’•												jz	ğ’‹¤			ğ’˜ğ’˜ğ’˜
# Return. Output is in register ğ’—ğ’‹™ğ’™
ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’‘±ğ’„°											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
---
#################
# def run_model()
ğ’•												jz	ğ’‹¤			ğ’•ğ’•ğ’•ğ’•ğ’•
#################################################################
# Prepare to call matmul:
#   Put pointer to layer1.weight in matmul.arg1 = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°
ğ’•ğ’‹™ğ’‘±ğ’‘±ğ’‘±											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°		ğ’‘±
#   Put pointer to input vector in matmul.arg2 = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’•ğ’„°											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°		ğ’‘±
#   Put size of layer1.weight in matmul.arg3 and matmul.arg4 (minus 1)
ğ’˜												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’—ğ’„°		ğ’‘±
ğ’•												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’˜ğ’„°		ğ’‘±
#   Put final dimension of input vector into matmul.arg5 (minus 1)
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’™ğ’„°		ğ’‘±
#   Put ğ’— into matmul.return_addr = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’‘±ğ’„°
ğ’—												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’‘±ğ’„°		ğ’‘±
#   Call matmul
ğ’•ğ’•ğ’•ğ’•ğ’•ğ’•											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder: Return from matmul
ğ’•												jz	ğ’‹¤			ğ’—
#################################################################
# Copy matmul result back to run_model's namespace
#   Put counter for number of elements to copy in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’˜												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to destination in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™ ğ’˜											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   Put pointer to source in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°
ğ’—ğ’‹™ğ’™ ğ’˜											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Copy source to destination
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°ğ’„°										ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’—ğ’—
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’—ğ’—ğ’—			ğ’‘±
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to copy next element
ğ’—ğ’—												ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break loop
ğ’•												jz	ğ’‹¤			ğ’—ğ’—ğ’—
#################################################################
# Add bias
#   Put counter for number of elements to add in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’˜												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to vector in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™ ğ’˜											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   Put pointer to bias in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°
ğ’•ğ’‹™ğ’•ğ’˜											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Add bias to vector
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°							ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’—ğ’—ğ’—ğ’—
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’—ğ’—ğ’—ğ’—ğ’—		ğ’‘±
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to add next element
ğ’—ğ’—ğ’—ğ’—											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break loop
ğ’•												jz	ğ’‹¤			ğ’—ğ’—ğ’—ğ’—ğ’—
#################################################################
# Apply ReLU
#   Put counter for number of elements in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’˜												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to vector in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™ ğ’˜											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   If element greater than zero, jump ahead
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°										jgz	ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—	ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—
#   Set element to zero
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’‘±
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—		ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to rectify next element
ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break rectifier loop
ğ’•												jz	ğ’‹¤			ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—ğ’—
#################################################################
# Prepare to call matmul on layer 2:
#   Put pointer to layer2.weight in matmul.arg1 = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°
ğ’•ğ’‹™ğ’–ğ’‘±ğ’‘±											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°		ğ’‘±
#   Put pointer to input vector in matmul.arg2 = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°
ğ’˜ğ’‹™ğ’™												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°		ğ’‘±
#   Put size of layer2.weight in matmul.arg3 and matmul.arg4 (minus 1)
ğ’–												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’—ğ’„°		ğ’‘±
ğ’˜												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’˜ğ’„°		ğ’‘±
#   Put final dimension of input vector into matmul.arg5 (minus 1)
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’™ğ’„°		ğ’‘±
#   Put ğ’— into matmul.return_addr = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’‘±ğ’„°
ğ’Œ‹ğ’Œ‹												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’‘±ğ’„°		ğ’‘±
#   Call matmul
ğ’•ğ’•ğ’•ğ’•ğ’•ğ’•											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder: Return from matmul
ğ’•												jz	ğ’‹¤			ğ’Œ‹ğ’Œ‹
#################################################################
# Copy matmul result back to run_model's namespace
#   Put counter for number of elements to copy in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’–												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to destination in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™ ğ’–											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   Put pointer to source in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°
ğ’—ğ’‹™ğ’™ ğ’–											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Copy source to destination
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°ğ’„°										ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’Œ‹ğ’Œ‹ğ’Œ‹
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹		ğ’‘±
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to copy next element
ğ’Œ‹ğ’Œ‹ğ’Œ‹												ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break loop
ğ’•												jz	ğ’‹¤			ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹
#################################################################
# Add bias
#   Put counter for number of elements to add in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’–												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to vector in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™ ğ’–											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   Put pointer to bias in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°
ğ’•ğ’‹™ğ’—ğ’–											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Add bias to vector
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°							ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹		ğ’‘±
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to add next element
ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break loop
ğ’•												jz	ğ’‹¤			ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹
#################################################################
# Apply ReLU
#   Put counter for number of elements in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’–												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to vector in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™ ğ’–											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   If element greater than zero, jump ahead
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°										jgz	ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹	ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹
#   Set element to zero
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’‘±
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹		ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to rectify next element
ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break rectifier loop
ğ’•												jz	ğ’‹¤			ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹ğ’Œ‹
#################################################################
# Prepare to call matmul:
#   Put pointer to layer3.weight in matmul.arg1 = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°
ğ’•ğ’‹™ğ’˜ğ’‘±ğ’‘±											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’•ğ’„°		ğ’‘±
#   Put pointer to input vector in matmul.arg2 = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°
ğ’˜ğ’‹™ğ’™												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’–ğ’„°		ğ’‘±
#   Put size of layer3.weight in matmul.arg3 and matmul.arg4 (minus 1)
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’—ğ’„°		ğ’‘±
ğ’–												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’˜ğ’„°		ğ’‘±
#   Put final dimension of input vector into matmul.arg5 (minus 1)
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’™ğ’„°		ğ’‘±
#   Put ğ’— into matmul.return_addr = ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’‘±ğ’„°
ğ’™												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’—ğ’‹™ğ’‘±ğ’„°		ğ’‘±
#   Call matmul
ğ’•ğ’•ğ’•ğ’•ğ’•ğ’•											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder: Return from matmul
ğ’•												jz	ğ’‹¤			ğ’™
#################################################################
# Copy matmul result back to run_model's namespace
#   Put counter for number of elements to copy in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to destination in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   Put pointer to source in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°
ğ’—ğ’‹™ğ’™												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Copy source to destination
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°ğ’„°										ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’™ğ’™
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’™ğ’™ğ’™			ğ’‘±
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to copy next element
ğ’™ğ’™												ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break loop
ğ’•												jz	ğ’‹¤			ğ’™ğ’™ğ’™
#################################################################
# Add bias
#   Put counter for number of elements to add in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°
ğ’‘±												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
#   Put pointer to vector in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°
ğ’˜ğ’‹™ğ’™											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
#   Put pointer to bias in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°
ğ’•ğ’‹™ğ’™											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Add bias to vector
ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°ğ’„°ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°							ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°ğ’„°	ğ’™ğ’™ğ’™ğ’™
#   If counter == 0, break
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°											jz	ğ’™ğ’™ğ’™ğ’™ğ’™		ğ’‘±
#   Decrement counter and pointers
ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°										ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’‘±ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’•ğ’„°		ğ’‘±
ğ’‹™ğ’‘±ğ’•ğ’„¿ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’Œ‹ğ’–ğ’„°		ğ’‘±
#   Loop to add next element
ğ’™ğ’™ğ’™ğ’™											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# NOP placeholder to break loop
ğ’•												jz	ğ’‹¤			ğ’™ğ’™ğ’™ğ’™ğ’™
# Un-normalize output
#   output *= std
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’™ğ’„°  ğ’‘±ğ’‹™ğ’Œ‹ğ’› ğ’ğ’— ğ’Œğ’ ğ’— ğ’Œğ’› ğ’Œ‹ğ’– ğ’ğ’™ ğ’Œ ğ’– ğ’™ğ’• ğ’ğ’– ğ’™ ğ’Œ ğ’™ğ’— ğ’Œğ’š ğ’ğ’› ğ’Œğ’š	ğ’€€ğ’º	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’™ğ’„°	ğ’‘±
#   output *= mean
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’™ğ’„°ğ’€€ğ’ˆ¾ğ’•ğ’‹™ğ’™ ğ’˜ ğ’™ğ’˜ ğ’š ğ’‘± ğ’ğ’š ğ’™ğ’œ ğ’™ ğ’Œğ’š ğ’– ğ’ğ’˜ ğ’ğ’˜ ğ’› ğ’Œ‹ğ’› ğ’ğ’™ ğ’Œğ’š	ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’™ğ’„°	ğ’‘±
# Return address was provided in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’‘±ğ’„°
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’‘±ğ’„°											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
---
# main()
# Get a pointer to the first input pair, which is stored in ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’šğ’‘±ğ’„° and ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’šğ’•ğ’„°
ğ’•ğ’‹™ğ’šğ’‘±											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’•ğ’„°		ğ’•ğ’•
# Prepare to call run_model:
#   Put pointer to current input pair into run_model.arg1 = ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’•ğ’„°
ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’•ğ’„°											ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’•ğ’„°		ğ’–ğ’–
#   Put ğ’– into run_model.return_addr = ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’‘±ğ’„°
ğ’–												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’‘±ğ’„°		ğ’‘±
#   Call run_model
ğ’•ğ’•ğ’•ğ’•ğ’•											ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
# Return from run_model
ğ’•												jz	ğ’‹¤			ğ’–
# Print run_model() return value, which is in ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’™ğ’„°
ğ’ƒ»ğ’‹ƒğ’˜ğ’‹™ğ’™ğ’„°											ğ’‹«ğ’ˆ¥	ğ’‹¤			ğ’‘±
# Check if pointer is equal to the last input
ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’•ğ’„°ğ’„¿ğ’ˆ¾ğ’•ğ’‹™ğ’›ğ’‘±									ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’–ğ’„°		ğ’‘±
# If it is, goto end of file
ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’–ğ’„°											jz	ğ’Œ‹			ğ’‘±
# Else increment pointer to next input pair
ğ’‘±ğ’‹™ğ’•ğ’€€ğ’ˆ¾ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’•ğ’„°										ğ’ˆ­ğ’„©	ğ’ƒ»ğ’‹ƒğ’‘±ğ’‹™ğ’•ğ’„°		ğ’‘±
# Loop back to ğ’–ğ’–
ğ’–ğ’–												ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
---
# Load model parameters
ğ’•												jz	ğ’‹¤			ğ’•
# Register allocation conventions: 
# 0;...: scratch
# 1;...: data
# 2;...: ReLU
# 3;...: matmul
# 4;...: run_model
# 5x2 weight in 1;0,0,0 - 1;0,4,1
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’‘±ğ’‘±ğ’„°	ğ’‘±
ğ’–		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’•ğ’‘±ğ’„°	ğ’‘±
ğ’—		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’–ğ’‘±ğ’„°	ğ’‘±
ğ’–		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’—ğ’‘±ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’˜ğ’‘±ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’‘±ğ’•ğ’„°	ğ’‘±
ğ’˜		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’•ğ’•ğ’„°	ğ’‘±
ğ’˜		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’–ğ’•ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’—ğ’•ğ’„°	ğ’‘±
ğ’˜		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’‘±ğ’˜ğ’•ğ’„°	ğ’‘±
# 5x1 bias in   1;1,0 - 1;1,4
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’•ğ’‘±ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’•ğ’•ğ’„°	ğ’‘±
ğ’–		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’•ğ’–ğ’„°	ğ’‘±
ğ’—		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’•ğ’—ğ’„°	ğ’‘±
ğ’˜		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’•ğ’˜ğ’„°	ğ’‘±
# 3x5 weight in 1;2,0,0 - 1;2,5,2
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’‘±ğ’‘±ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’•ğ’‘±ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’–ğ’‘±ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’‘±ğ’•ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’•ğ’•ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’–ğ’•ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’‘±ğ’–ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’•ğ’–ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’–ğ’–ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’‘±ğ’—ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’•ğ’—ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’–ğ’—ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’‘±ğ’˜ğ’„°	ğ’‘±
ğ’‘±		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’•ğ’˜ğ’„°	ğ’‘±
ğ’•		ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’–ğ’–ğ’˜ğ’„°	ğ’‘±
# 3x1 bias in   1;3,0 - 1;3,2
ğ’™ğ’„¿ğ’ˆ¾ğ’‘±	ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’—ğ’‘±ğ’„°	ğ’‘±
ğ’™ğ’„¿ğ’ˆ¾ğ’‘±	ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’—ğ’•ğ’„°	ğ’‘±
ğ’™ğ’„¿ğ’ˆ¾ğ’‘±	ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’—ğ’–ğ’„°	ğ’‘±
# 1x3 weight in 1;4,0,0 - 1;4,0,2
ğ’•	ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’˜ğ’‘±ğ’‘±ğ’„°	ğ’‘±
ğ’•	ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’˜ğ’‘±ğ’•ğ’„°	ğ’‘±
ğ’•	ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’˜ğ’‘±ğ’–ğ’„°	ğ’‘±
# 1x1 bias in   1;5,0
ğ’™ğ’„¿ğ’ˆ¾ğ’‘±	ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’™ğ’‘±ğ’„°	ğ’‘±
---
# Load model inputs
# input pair 1 in 1;6,0 and 1;6,1
ğ’šğ’„¿ğ’ˆ¾ğ’‘±											ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’šğ’‘±ğ’„°	ğ’‘±
ğ’–												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’šğ’•ğ’„°	ğ’‘±
# input pair 2 in 1;7,0 and 1;7,1
ğ’š												ğ’€ğ’£	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’›ğ’‘±ğ’„°	ğ’‘±
ğ’•												ğ’ˆ¨	ğ’ƒ»ğ’‹ƒğ’•ğ’‹™ğ’›ğ’•ğ’„°	ğ’‘±
---
# After data is loaded, jump to main():
ğ’•ğ’•												ğ’‡”ğ’ˆ¾	ğ’‹¤			ğ’‘±
---
# END OF FILE
ğ’•												jz	ğ’‹¤			ğ’Œ‹
---
colophon
